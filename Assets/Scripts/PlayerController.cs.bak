using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class PlayerController : MonoBehaviour {

	private floorController floarController;
    private const string FRONT = "front";
    private const string RIGHT = "right";
    private const string LEFT = "left";
    private const string BACK = "back";
    private string meDirection;//プレイヤーの向き

    private GameObject player;
    private GameObject miss;
    private GameObject goal;
    Vector3 pos;
    Vector3 defaultPos;
    Vector3 defaultRot;
    private int count;
    private int clickCount;
    private int clickCountX;
    private List<string> moveList;
    List<GameObject> moveObjList;
    private bool checkpointflag;
    private int commandcount = 1;

    public Material rightmaterial;
    public Material leftmaterial;
    public Material frontmaterial;
    public Material backmaterial;
    public string nextScenename;
    private CSVWriter CSV;  //CSVWriterクラスを読み込み

    private panelController panelController;

    // Use this for initialization
    void Start () {
        player = GameObject.Find("Player");
        pos = GetComponent<Transform>().position;
        defaultPos = player.transform.position;
        defaultRot = player.transform.localEulerAngles;
        clickCount = 0;
        clickCountX = 0;
        checkpointflag = false;
        meDirection = BACK;
        moveObjList = new List<GameObject>();
        moveList = new List<string>();

        CSV = GameObject.Find("CSVWriter").GetComponent<CSVWriter>();  //GameObject CSVWriterを探し出してアタッチする
        panelController = GameObject.Find("edit").GetComponent<panelController>();
        
        floarController = GameObject.Find("floar").GetComponent<floorController>();
    }
	
	// Update is called once per frame
	void Update () {
	}

    public void createPanel(string tag)
    {

            float posY = 0F;
            float posX = 0F;
            if (clickCount < 10)
            {
                posY = clickCount * 0.5F;
                posX = clickCountX * 1.5F;
            }
            else
            {
                clickCount = 0;
                clickCountX++;
                posY = clickCount;
                posX = clickCountX * 1.5F;

            }

            GameObject prefab = (GameObject)Resources.Load(tag);
            Vector3 postion = new Vector3(x: 3.6F + posX, y: 4.0F - posY, z: 0);
            moveObjList.Add(Instantiate(prefab, postion, rotation: Quaternion.identity));
            clickCount++;
            moveList.Add(tag);
    }


    public void moveStart()
    {
        float timeCount = 1F;
        foreach (string moveCommand in moveList)
        {

            StartCoroutine(sleep(moveCommand, timeCount));
            CSV.WriteCSV(moveCommand + "," + commandcount);
            commandcount++;
            timeCount++;
        }
        timeCount = 0F;
        clickCount = 0;
        clickCountX = 0;
        moveList.Clear();
        player.transform.position = defaultPos;
        player.transform.localEulerAngles = defaultRot;
        count = 0;
        checkpointflag = false;
        meDirection = BACK;
        this.GetComponent<Renderer>().material = backmaterial;
        Destroy(miss);
        Destroy(goal);



        List<GameObject> panelList = panelController.GetPanelList();
        foreach (GameObject tmpObj in panelList)
        {
            StartCoroutine(sleep(tmpObj.tag, timeCount));
            timeCount++;
        }

        timeCount = 0F;
    }

    private void move()
    {
        
        Quaternion q = this.transform.rotation;
        float moveZ = q.eulerAngles.z;
        if (count > 0 && moveZ == 0f){
            pos = transform.position;
            pos.y += 1.5f + 0.5f;
            player.transform.position = pos;
            count++;
        }else if (count <= 0 &&  moveZ == 0f){
            pos = transform.position;
            pos.y += 1.5f;
            player.transform.position = pos;
            count++;
        }else if (count > 0 && moveZ == 90f || moveZ == -270f){
            pos = transform.position;
            pos.x += 1.5f + 0.5f;
            player.transform.position = pos;
            count++;
        }else if (count > 0 && moveZ == 180f || moveZ == -180f){
            pos = transform.position;
            pos.y -= 1.5f + 0.5f;
            player.transform.position = pos;
            count++;
        }else if (count > 0 && moveZ == 270f|| moveZ == -90f){
            pos = transform.position;
            pos.x -= 1.5f + 0.5f;
            player.transform.position = pos;
            count++;
        }
    }

    private void Back()
    {

        Quaternion q = this.transform.rotation;
        float backZ = q.eulerAngles.z;
        if (count > 0 && backZ == 0f)
        {
            pos = transform.position;
            pos.y -= 1.5f + 0.5f;
            player.transform.position = pos;
            count++;
        }
        else if (count <= 0 && backZ == 0f)
        {
            pos = transform.position;
            pos.y -= 1.5f;
            player.transform.position = pos;
            count++;
        }
        else if (count > 0 && backZ == 90f || backZ == -270f)
        {
            pos = transform.position;
            pos.x -= 1.5f + 0.5f;
            player.transform.position = pos;
            count++;
        }
        else if (count > 0 && backZ == 180f || backZ == -180f)
        {
            pos = transform.position;
            pos.y += 1.5f + 0.5f;
            player.transform.position = pos;
            count++;
        }
        else if (count > 0 && backZ == 270f || backZ == -90f)
        {
            pos = transform.position;
            pos.x += 1.5f + 0.5f;
            player.transform.position = pos;
            count++;
        }
    }

    private void Right(){
        transform.Rotate(new Vector3(0, 0, 90));
        switch (meDirection)
        {
            case FRONT:
                this.GetComponent<Renderer>().material = leftmaterial;
                meDirection = LEFT;
                break;
            case RIGHT:
                this.GetComponent<Renderer>().material = frontmaterial;
                meDirection = FRONT;
                break;
            case LEFT:
                this.GetComponent<Renderer>().material = backmaterial;
                meDirection = BACK;
                break;
            case BACK:
                this.GetComponent<Renderer>().material = rightmaterial;
                meDirection = RIGHT;
                break;
        }

    }

    private void Left(){
        transform.Rotate(new Vector3(0, 0, -90));
        switch (meDirection)
        {
            case FRONT:
                this.GetComponent<Renderer>().material = rightmaterial;
                meDirection = RIGHT;
                break;
            case RIGHT:
                this.GetComponent<Renderer>().material = backmaterial;
                meDirection =BACK;
                break;
            case LEFT:
                this.GetComponent<Renderer>().material =frontmaterial;
                meDirection = FRONT;
                break;
            case BACK:
                this.GetComponent<Renderer>().material = leftmaterial;
                meDirection = LEFT;
                break;
        }
    }

    IEnumerator sleep(string moveCommand,float timeCount)
    {
        yield return new WaitForSeconds(timeCount);
        switch (moveCommand)
        {
            case "moveOn":
                move();
                break;

            case "turnRight":
                Right();
                break;

            case "turnLeft":
                Left();
                break;

            case "backOn":
                Back();
                break;

            case "action":
                Action();
                break;
        }
    }

    private void Action()
    {
        if (checkpointflag)
        {
            Debug.Log("お使い");
        }
        else
        {
            Debug.Log("だれもいないよ");
        }
    }

    public void Reset()
    {
        clickCount = 0;
        clickCountX = 0;
        moveList.Clear();
        player.transform.position = defaultPos;
        player.transform.localEulerAngles = defaultRot;
        count = 0;
        checkpointflag = false;

        foreach (GameObject obj in moveObjList)
        {
            Destroy(obj);
        }
        moveObjList.Clear();

        meDirection = BACK;
        this.GetComponent<Renderer>().material = backmaterial;

        Destroy(miss);
        Destroy(goal);

        panelController.ResetPanelList();
    }

    void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "goal")
        {
            if (checkpointflag)
            {
                goal = (GameObject)Resources.Load("clear");
                Vector3 postion = new Vector3(x: -5.5F, y: 0F, z: -5F);
                goal = Instantiate(goal, postion, Quaternion.identity);
                StartCoroutine(WaiTtime(3));
            }
            else
            {
                miss = (GameObject)Resources.Load("miss");
                Vector3 postion = new Vector3(x: -5.5F, y: 0F, z: -5F);
                miss = Instantiate(miss, postion, Quaternion.identity);
            }
        }
        if (other.gameObject.tag == "wall")
        {
            miss = (GameObject)Resources.Load("miss");
            Vector3 postion = new Vector3(x: -5.5F, y: 0F, z: -5F);
            miss = Instantiate(miss, postion, Quaternion.identity);
        }

        if (other.gameObject.tag == "checkpoint")
        {
            checkpointflag = true;
        }
    }
    IEnumerator WaiTtime(int num)
    {
        yield return new WaitForSeconds(num);
        commandcount = 1;
        SceneManager.LoadScene(nextScenename);
    }
    public void OnTriggerExit(Collider other)
    {
        if(other.gameObject.tag == "floar")
        {
            Debug.Log("into OnTriggerExit");
            GameObject oya = other.transform.parent.gameObject;
            floarController.changeMaterial(oya);
            Debug.Log("Material has changed");
        }
    }
}
